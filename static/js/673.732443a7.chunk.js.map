{"version":3,"file":"static/js/673.732443a7.chunk.js","mappings":"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","sources":["../node_modules/escape-html/index.js","../node_modules/interweave/src/Element.tsx","../node_modules/interweave/src/Filter.ts","../node_modules/interweave/src/constants.ts","../node_modules/interweave/src/StyleFilter.ts","../node_modules/interweave/src/Parser.ts","../node_modules/interweave/src/Interweave.tsx","../node_modules/interweave/src/Markup.tsx","../node_modules/interweave/src/match.ts","../node_modules/interweave/src/Matcher.ts","../node_modules/reactstrap/es/Breadcrumb.js","../node_modules/reactstrap/es/BreadcrumbItem.js"],"sourcesContent":["/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n","import React from 'react';\nimport { ElementProps } from './types';\n\nexport default function Element({\n  attributes = {},\n  className,\n  children = null,\n  selfClose = false,\n  tagName,\n}: ElementProps) {\n  const Tag = tagName as 'span';\n\n  return selfClose ? (\n    <Tag className={className} {...attributes} />\n  ) : (\n    <Tag className={className} {...attributes}>\n      {children}\n    </Tag>\n  );\n}\n","import { ElementAttributes, FilterInterface } from './types';\n\nexport default class Filter implements FilterInterface {\n  /**\n   * Filter and clean an HTML attribute value.\n   */\n  attribute<K extends keyof ElementAttributes>(\n    name: K,\n    value: ElementAttributes[K],\n  ): ElementAttributes[K] | null | undefined {\n    return value;\n  }\n\n  /**\n   * Filter and clean an HTML node.\n   */\n  node(name: string, node: HTMLElement): HTMLElement | null {\n    return node;\n  }\n}\n","/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */\n\nimport { ConfigMap, FilterMap, NodeConfig } from './types';\n\n// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories\nexport const TYPE_FLOW = 1;\nexport const TYPE_SECTION = 1 << 1;\nexport const TYPE_HEADING = 1 << 2;\nexport const TYPE_PHRASING = 1 << 3;\nexport const TYPE_EMBEDDED = 1 << 4;\nexport const TYPE_INTERACTIVE = 1 << 5;\nexport const TYPE_PALPABLE = 1 << 6;\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst tagConfigs: { [tagName: string]: Partial<NodeConfig> } = {\n  a: {\n    content: TYPE_FLOW | TYPE_PHRASING,\n    self: false,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE,\n  },\n  address: {\n    invalid: [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'address',\n      'article',\n      'aside',\n      'section',\n      'div',\n      'header',\n      'footer',\n    ],\n    self: false,\n  },\n  audio: {\n    children: ['track', 'source'],\n  },\n  br: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true,\n  },\n  body: {\n    content:\n      TYPE_FLOW |\n      TYPE_SECTION |\n      TYPE_HEADING |\n      TYPE_PHRASING |\n      TYPE_EMBEDDED |\n      TYPE_INTERACTIVE |\n      TYPE_PALPABLE,\n  },\n  button: {\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE,\n  },\n  caption: {\n    content: TYPE_FLOW,\n    parent: ['table'],\n  },\n  col: {\n    parent: ['colgroup'],\n    void: true,\n  },\n  colgroup: {\n    children: ['col'],\n    parent: ['table'],\n  },\n  details: {\n    children: ['summary'],\n    type: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE,\n  },\n  dd: {\n    content: TYPE_FLOW,\n    parent: ['dl'],\n  },\n  dl: {\n    children: ['dt', 'dd'],\n    type: TYPE_FLOW,\n  },\n  dt: {\n    content: TYPE_FLOW,\n    invalid: ['footer', 'header'],\n    parent: ['dl'],\n  },\n  figcaption: {\n    content: TYPE_FLOW,\n    parent: ['figure'],\n  },\n  footer: {\n    invalid: ['footer', 'header'],\n  },\n  header: {\n    invalid: ['footer', 'header'],\n  },\n  hr: {\n    type: TYPE_FLOW,\n    void: true,\n  },\n  img: {\n    void: true,\n  },\n  li: {\n    content: TYPE_FLOW,\n    parent: ['ul', 'ol', 'menu'],\n  },\n  main: {\n    self: false,\n  },\n  ol: {\n    children: ['li'],\n    type: TYPE_FLOW,\n  },\n  picture: {\n    children: ['source', 'img'],\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED,\n  },\n  rb: {\n    parent: ['ruby', 'rtc'],\n  },\n  rp: {\n    parent: ['ruby', 'rtc'],\n  },\n  rt: {\n    content: TYPE_PHRASING,\n    parent: ['ruby', 'rtc'],\n  },\n  rtc: {\n    content: TYPE_PHRASING,\n    parent: ['ruby'],\n  },\n  ruby: {\n    children: ['rb', 'rp', 'rt', 'rtc'],\n  },\n  source: {\n    parent: ['audio', 'video', 'picture'],\n    void: true,\n  },\n  summary: {\n    content: TYPE_PHRASING,\n    parent: ['details'],\n  },\n  table: {\n    children: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],\n    type: TYPE_FLOW,\n  },\n  tbody: {\n    parent: ['table'],\n    children: ['tr'],\n  },\n  td: {\n    content: TYPE_FLOW,\n    parent: ['tr'],\n  },\n  tfoot: {\n    parent: ['table'],\n    children: ['tr'],\n  },\n  th: {\n    content: TYPE_FLOW,\n    parent: ['tr'],\n  },\n  thead: {\n    parent: ['table'],\n    children: ['tr'],\n  },\n  tr: {\n    parent: ['table', 'tbody', 'thead', 'tfoot'],\n    children: ['th', 'td'],\n  },\n  track: {\n    parent: ['audio', 'video'],\n    void: true,\n  },\n  ul: {\n    children: ['li'],\n    type: TYPE_FLOW,\n  },\n  video: {\n    children: ['track', 'source'],\n  },\n  wbr: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true,\n  },\n};\n\nfunction createConfigBuilder(config: Partial<NodeConfig>): (tagName: string) => void {\n  return (tagName: string) => {\n    tagConfigs[tagName] = {\n      ...config,\n      ...tagConfigs[tagName],\n    };\n  };\n}\n\n['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(\n  createConfigBuilder({\n    content: TYPE_FLOW,\n    type: TYPE_FLOW | TYPE_PALPABLE,\n  }),\n);\n\n[\n  'abbr',\n  'b',\n  'bdi',\n  'bdo',\n  'cite',\n  'code',\n  'data',\n  'dfn',\n  'em',\n  'i',\n  'kbd',\n  'mark',\n  'q',\n  'ruby',\n  'samp',\n  'strong',\n  'sub',\n  'sup',\n  'time',\n  'u',\n  'var',\n].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE,\n  }),\n);\n\n['p', 'pre'].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PALPABLE,\n  }),\n);\n\n['s', 'small', 'span', 'del', 'ins'].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING,\n  }),\n);\n\n['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(\n  createConfigBuilder({\n    content: TYPE_FLOW,\n    type: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE,\n  }),\n);\n\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE,\n  }),\n);\n\n['audio', 'canvas', 'iframe', 'img', 'video'].forEach(\n  createConfigBuilder({\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE,\n  }),\n);\n\n// Disable this map from being modified\nexport const TAGS: ConfigMap = Object.freeze(tagConfigs);\n\n// Tags that should never be allowed, even if the allow list is disabled\nexport const BANNED_TAG_LIST = [\n  'applet',\n  'base',\n  'body',\n  'command',\n  'embed',\n  'frame',\n  'frameset',\n  'head',\n  'html',\n  'link',\n  'meta',\n  'noscript',\n  'object',\n  'script',\n  'style',\n  'title',\n];\n\nexport const ALLOWED_TAG_LIST = Object.keys(TAGS).filter(\n  (tag) => tag !== 'canvas' && tag !== 'iframe',\n);\n\n// Filters apply to HTML attributes\nexport const FILTER_ALLOW = 1;\nexport const FILTER_DENY = 2;\nexport const FILTER_CAST_NUMBER = 3;\nexport const FILTER_CAST_BOOL = 4;\nexport const FILTER_NO_CAST = 5;\n\n// Attributes not listed here will be denied\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\nexport const ATTRIBUTES: FilterMap = Object.freeze({\n  alt: FILTER_ALLOW,\n  cite: FILTER_ALLOW,\n  class: FILTER_ALLOW,\n  colspan: FILTER_CAST_NUMBER,\n  controls: FILTER_CAST_BOOL,\n  datetime: FILTER_ALLOW,\n  default: FILTER_CAST_BOOL,\n  disabled: FILTER_CAST_BOOL,\n  dir: FILTER_ALLOW,\n  height: FILTER_ALLOW,\n  href: FILTER_ALLOW,\n  id: FILTER_ALLOW,\n  kind: FILTER_ALLOW,\n  label: FILTER_ALLOW,\n  lang: FILTER_ALLOW,\n  loading: FILTER_ALLOW,\n  loop: FILTER_CAST_BOOL,\n  media: FILTER_ALLOW,\n  muted: FILTER_CAST_BOOL,\n  poster: FILTER_ALLOW,\n  role: FILTER_ALLOW,\n  rowspan: FILTER_CAST_NUMBER,\n  scope: FILTER_ALLOW,\n  sizes: FILTER_ALLOW,\n  span: FILTER_CAST_NUMBER,\n  start: FILTER_CAST_NUMBER,\n  style: FILTER_NO_CAST,\n  src: FILTER_ALLOW,\n  srclang: FILTER_ALLOW,\n  srcset: FILTER_ALLOW,\n  target: FILTER_ALLOW,\n  title: FILTER_ALLOW,\n  type: FILTER_ALLOW,\n  width: FILTER_ALLOW,\n});\n\n// Attributes to camel case for React props\nexport const ATTRIBUTES_TO_PROPS: { [key: string]: string } = Object.freeze({\n  class: 'className',\n  colspan: 'colSpan',\n  datetime: 'dateTime',\n  rowspan: 'rowSpan',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n});\n","import Filter from './Filter';\nimport { ElementAttributes } from './types';\n\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nexport default class StyleFilter extends Filter {\n  attribute<K extends keyof ElementAttributes>(\n    name: K,\n    value: ElementAttributes[K],\n  ): ElementAttributes[K] {\n    if (name === 'style') {\n      Object.keys(value).forEach((key) => {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    }\n\n    return value;\n  }\n}\n","/* eslint-disable no-bitwise, no-cond-assign, complexity */\n\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nimport {\n  ALLOWED_TAG_LIST,\n  ATTRIBUTES,\n  ATTRIBUTES_TO_PROPS,\n  BANNED_TAG_LIST,\n  FILTER_CAST_BOOL,\n  FILTER_CAST_NUMBER,\n  FILTER_DENY,\n  FILTER_NO_CAST,\n  TAGS,\n} from './constants';\nimport Element from './Element';\nimport StyleFilter from './StyleFilter';\nimport {\n  Attributes,\n  AttributeValue,\n  ChildrenNode,\n  ElementAttributes,\n  ElementProps,\n  FilterInterface,\n  MatcherElementsMap,\n  MatcherInterface,\n  Node,\n  NodeConfig,\n  ParserProps,\n} from './types';\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nexport default class Parser {\n  allowed: Set<string>;\n\n  banned: Set<string>;\n\n  blocked: Set<string>;\n\n  container?: HTMLElement;\n\n  content: Node[] = [];\n\n  props: ParserProps;\n\n  matchers: MatcherInterface[];\n\n  filters: FilterInterface[];\n\n  keyIndex: number;\n\n  constructor(\n    markup: string,\n    props: ParserProps = {},\n    matchers: MatcherInterface[] = [],\n    filters: FilterInterface[] = [],\n  ) {\n    if (__DEV__) {\n      if (markup && typeof markup !== 'string') {\n        throw new TypeError('Interweave parser requires a valid string.');\n      }\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [...filters, new StyleFilter()];\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set(props.allowList || ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n  applyAttributeFilters<K extends keyof ElementAttributes>(\n    name: K,\n    value: ElementAttributes[K],\n  ): ElementAttributes[K] {\n    return this.filters.reduce(\n      (nextValue, filter) =>\n        nextValue !== null && typeof filter.attribute === 'function'\n          ? filter.attribute(name, nextValue)\n          : nextValue,\n      value,\n    );\n  }\n\n  /**\n   * Loop through and apply all registered node filters.\n   */\n  applyNodeFilters(name: string, node: HTMLElement | null): HTMLElement | null {\n    // Allow null to be returned\n    return this.filters.reduce(\n      (nextNode, filter) =>\n        nextNode !== null && typeof filter.node === 'function'\n          ? filter.node(name, nextNode)\n          : nextNode,\n      node,\n    );\n  }\n\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n  applyMatchers(string: string, parentConfig: NodeConfig): ChildrenNode {\n    const elements: MatcherElementsMap = {};\n    const { props } = this;\n    let matchedString = string;\n    let elementIndex = 0;\n    let parts = null;\n\n    this.matchers.forEach((matcher) => {\n      const tagName = matcher.asTag().toLowerCase();\n      const config = this.getTagConfig(tagName);\n\n      // Skip matchers that have been disabled from props or are not supported\n      if (\n        (props as { [key: string]: unknown })[matcher.inverseName] ||\n        !this.isTagAllowed(tagName)\n      ) {\n        return;\n      }\n\n      // Skip matchers in which the child cannot be rendered\n      if (!this.canRenderChild(parentConfig, config)) {\n        return;\n      }\n\n      // Continuously trigger the matcher until no matches are found\n      let tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        const { index, length, match, valid, void: isVoid, ...partProps } = parts;\n        const tokenName = matcher.propName + elementIndex;\n\n        // Piece together a new string with interpolated tokens\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid\n            ? `{{{${tokenName}/}}}`\n            : `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n\n          this.keyIndex += 1;\n\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: match,\n            matcher,\n            props: {\n              ...props,\n              ...partProps,\n              key: this.keyIndex,\n            },\n          };\n        } else {\n          tokenizedString += match;\n        }\n\n        // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || match.length));\n        }\n      }\n\n      // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n  canRenderChild(parentConfig: NodeConfig, childConfig: NodeConfig): boolean {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    }\n\n    // No children\n    if (parentConfig.void) {\n      return false;\n    }\n\n    // Valid children\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    }\n\n    // Valid parent\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    }\n\n    // Self nesting\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    }\n\n    // Content category type\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n  convertLineBreaks(markup: string): string {\n    const { noHtml, disableLineBreaks } = this.props;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    }\n\n    // Replace carriage returns\n    let nextMarkup = markup.replace(/\\r\\n/g, '\\n');\n\n    // Replace long line feeds\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n');\n\n    // Replace line feeds with `<br/>`s\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n\n    return nextMarkup;\n  }\n\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n  createContainer(markup: string): HTMLElement | undefined {\n    const factory =\n      (typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL) || createDocument;\n    const doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    const tag = this.props.containerTagName || 'body';\n    const el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (__DEV__) {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n  extractAttributes(node: HTMLElement): Attributes | null {\n    const { allowAttributes } = this.props;\n    const attributes: Attributes = {};\n    let count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    }\n\n    Array.from(node.attributes).forEach((attr) => {\n      const { name, value } = attr;\n      const newName = name.toLowerCase();\n      const filter = ATTRIBUTES[newName] || ATTRIBUTES[name];\n\n      // Verify the node is safe from attacks\n      if (!this.isSafe(node)) {\n        return;\n      }\n\n      // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n      if (!newName.match(ALLOWED_ATTRS)) {\n        if (\n          (!allowAttributes && (!filter || filter === FILTER_DENY)) ||\n          newName.startsWith('on') ||\n          value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i)\n        ) {\n          return;\n        }\n      }\n\n      // Apply attribute filters\n      let newValue: AttributeValue = newName === 'style' ? this.extractStyleAttribute(node) : value;\n\n      // Cast to boolean\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true;\n\n        // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue));\n\n        // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(\n        newName as keyof ElementAttributes,\n        newValue,\n      ) as AttributeValue;\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n  extractStyleAttribute(node: HTMLElement): object {\n    const styles: { [key: string]: number | string } = {};\n\n    Array.from(node.style).forEach((key) => {\n      const value = node.style[key as keyof CSSStyleDeclaration];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase())] = value;\n      }\n    });\n\n    return styles;\n  }\n\n  /**\n   * Return configuration for a specific tag.\n   */\n  getTagConfig(tagName: string): NodeConfig {\n    const common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false,\n    };\n\n    // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n    if (TAGS[tagName]) {\n      return {\n        ...common,\n        ...TAGS[tagName],\n        tagName,\n      };\n    }\n\n    return common;\n  }\n\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n  isSafe(node: HTMLElement): boolean {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      const href = node.getAttribute('href');\n\n      // Fragment protocols start with about:\n      // So let's just allow them\n      if (href && href.charAt(0) === '#') {\n        return true;\n      }\n\n      const protocol = node.protocol.toLowerCase();\n\n      return (\n        protocol === ':' ||\n        protocol === 'http:' ||\n        protocol === 'https:' ||\n        protocol === 'mailto:' ||\n        protocol === 'tel:'\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n  isTagAllowed(tagName: string): boolean {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    }\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n  parse(): Node[] {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n  parseNode(parentNode: HTMLElement, parentConfig: NodeConfig): Node[] {\n    const {\n      noHtml,\n      noHtmlExceptMatchers,\n      allowElements,\n      transform,\n      transformOnlyAllowList,\n    } = this.props;\n    let content: Node[] = [];\n    let mergedText = '';\n\n    Array.from(parentNode.childNodes).forEach((node) => {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        const tagName = node.nodeName.toLowerCase();\n        const config = this.getTagConfig(tagName);\n\n        // Persist any previous text\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        }\n\n        // Apply node filters first\n        const nextNode = this.applyNodeFilters(tagName, node as HTMLElement);\n\n        if (!nextNode) {\n          return;\n        }\n\n        // Apply transformation second\n        let children;\n\n        if (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n          this.keyIndex += 1;\n          const key = this.keyIndex;\n\n          // Must occur after key is set\n          children = this.parseNode(nextNode, config);\n\n          const transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          } else if (typeof transformed !== 'undefined') {\n            content.push(React.cloneElement(transformed as React.ReactElement<unknown>, { key }));\n\n            return;\n          }\n\n          // Reset as we're not using the transformation\n          this.keyIndex = key - 1;\n        }\n\n        // Never allow these tags (except via a transformer)\n        if (this.banned.has(tagName)) {\n          return;\n        }\n\n        // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n        if (\n          !(noHtml || (noHtmlExceptMatchers && tagName !== 'br')) &&\n          this.isTagAllowed(tagName) &&\n          (allowElements || this.canRenderChild(parentConfig, config))\n        ) {\n          this.keyIndex += 1;\n\n          // Build the props as it makes it easier to test\n          const attributes = this.extractAttributes(nextNode);\n          const elementProps: ElementProps = {\n            tagName,\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push(\n            React.createElement(\n              Element,\n              { ...elementProps, key: this.keyIndex },\n              children || this.parseNode(nextNode, config),\n            ),\n          );\n\n          // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = content.concat(\n            this.parseNode(nextNode, config.tagName ? config : parentConfig),\n          );\n        }\n\n        // Apply matchers if a text node\n      } else if (node.nodeType === TEXT_NODE) {\n        const text =\n          noHtml && !noHtmlExceptMatchers\n            ? node.textContent\n            : this.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = content.concat(text);\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n  replaceTokens(tokenizedString: string, elements: MatcherElementsMap): ChildrenNode {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    const nodes: Node[] = [];\n    let text = tokenizedString;\n    let open: RegExpMatchArray | null = null;\n\n    // Find an open token tag\n    while ((open = text.match(OPEN_TOKEN))) {\n      const [match, tokenName] = open;\n      const startIndex = open.index!;\n      const isVoid = match.includes('/');\n\n      if (__DEV__) {\n        if (!elements[tokenName]) {\n          throw new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n        }\n      }\n\n      // Extract the previous non-token text\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex));\n\n        // Reduce text so that the closing tag will be found after the opening\n        text = text.slice(startIndex);\n      }\n\n      const { children, matcher, props: elementProps } = elements[tokenName];\n      let endIndex: number;\n\n      // Use tag as-is if void\n      if (isVoid) {\n        endIndex = match.length;\n\n        nodes.push(matcher.createElement(children, elementProps));\n\n        // Find the closing tag if not void\n      } else {\n        const close = text.match(new RegExp(`{{{/${tokenName}}}}`))!;\n\n        if (__DEV__) {\n          if (!close) {\n            throw new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n          }\n        }\n\n        endIndex = close.index! + close[0].length;\n\n        nodes.push(\n          matcher.createElement(\n            this.replaceTokens(text.slice(match.length, close.index!), elements),\n            elementProps,\n          ),\n        );\n      }\n\n      // Reduce text for the next interation\n      text = text.slice(endIndex);\n    }\n\n    // Extra the remaining text\n    if (text.length > 0) {\n      nodes.push(text);\n    }\n\n    // Reduce to a string if possible\n    if (nodes.length === 0) {\n      return '';\n    } else if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  }\n}\n","import React from 'react';\nimport Markup from './Markup';\nimport Parser from './Parser';\nimport { InterweaveProps } from './types';\n\nexport default function Interweave(props: InterweaveProps) {\n  const {\n    attributes,\n    className,\n    content = '',\n    disableFilters = false,\n    disableMatchers = false,\n    emptyContent = null,\n    filters = [],\n    matchers = [],\n    onAfterParse = null,\n    onBeforeParse = null,\n    tagName = 'span',\n    noWrap = false,\n    ...parserProps\n  } = props;\n  const allMatchers = disableMatchers ? [] : matchers;\n  const allFilters = disableFilters ? [] : filters;\n  const beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  const afterCallbacks = onAfterParse ? [onAfterParse] : [];\n\n  // Inherit callbacks from matchers\n  allMatchers.forEach((matcher) => {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  });\n\n  // Trigger before callbacks\n  const markup = beforeCallbacks.reduce((string, callback) => {\n    const nextString = callback(string, props);\n\n    if (__DEV__) {\n      if (typeof nextString !== 'string') {\n        throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n      }\n    }\n\n    return nextString;\n  }, content || '');\n\n  // Parse the markup\n  const parser = new Parser(markup, parserProps, allMatchers, allFilters);\n\n  // Trigger after callbacks\n  const nodes = afterCallbacks.reduce((parserNodes, callback) => {\n    const nextNodes = callback(parserNodes, props);\n\n    if (__DEV__) {\n      if (!Array.isArray(nextNodes)) {\n        throw new TypeError(\n          'Interweave `onAfterParse` must return an array of strings and React elements.',\n        );\n      }\n    }\n\n    return nextNodes;\n  }, parser.parse());\n\n  return (\n    <Markup\n      attributes={attributes}\n      className={className}\n      containerTagName={props.containerTagName}\n      emptyContent={emptyContent}\n      tagName={tagName}\n      noWrap={noWrap}\n      parsedContent={nodes.length === 0 ? undefined : nodes}\n    />\n  );\n}\n","/* eslint-disable react/jsx-fragments */\n\nimport React from 'react';\nimport Element from './Element';\nimport Parser from './Parser';\nimport { MarkupProps } from './types';\n\nexport default function Markup(props: MarkupProps) {\n  const {\n    attributes,\n    className,\n    containerTagName,\n    content,\n    emptyContent,\n    parsedContent,\n    tagName,\n  } = props;\n  const tag = containerTagName || tagName || 'span';\n  const noWrap = tag === 'fragment' ? true : props.noWrap;\n  let mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    const markup = new Parser(content || '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return <React.Fragment>{mainContent}</React.Fragment>;\n  }\n\n  return (\n    <Element attributes={attributes} className={className} tagName={tag}>\n      {mainContent}\n    </Element>\n  );\n}\n","import { MatchCallback, MatchResponse } from './types';\n\n/**\n * Trigger the actual pattern match and package the matched\n * response through a callback.\n */\nexport default function match<T>(\n  string: string,\n  pattern: RegExp | string,\n  callback: MatchCallback<T>,\n  isVoid: boolean = false,\n): MatchResponse<T> | null {\n  const matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));\n\n  if (!matches) {\n    return null;\n  }\n\n  return {\n    match: matches[0],\n    void: isVoid,\n    ...callback(matches),\n    index: matches.index!,\n    length: matches[0].length,\n    valid: true,\n  };\n}\n","import React from 'react';\nimport match from './match';\nimport { ChildrenNode, MatchCallback, MatcherInterface, MatchResponse, Node } from './types';\n\nexport default abstract class Matcher<Props extends object = {}, Options extends object = {}>\n  implements MatcherInterface<Props> {\n  greedy: boolean = false;\n\n  options: Options;\n\n  propName: string;\n\n  inverseName: string;\n\n  factory: React.ComponentType<Props> | null;\n\n  constructor(name: string, options?: Options, factory?: React.ComponentType<Props> | null) {\n    if (__DEV__) {\n      if (!name || name.toLowerCase() === 'html') {\n        throw new Error(`The matcher name \"${name}\" is not allowed.`);\n      }\n    }\n\n    // @ts-expect-error\n    this.options = { ...options };\n    this.propName = name;\n    this.inverseName = `no${name.charAt(0).toUpperCase() + name.slice(1)}`;\n    this.factory = factory || null;\n  }\n\n  /**\n   * Attempts to create a React element using a custom user provided factory,\n   * or the default matcher factory.\n   */\n  createElement(children: ChildrenNode, props: Props): Node {\n    const element = this.factory\n      ? React.createElement(this.factory, props, children)\n      : this.replaceWith(children, props);\n\n    if (__DEV__) {\n      if (typeof element !== 'string' && !React.isValidElement(element)) {\n        throw new Error(`Invalid React element created from ${this.constructor.name}.`);\n      }\n    }\n\n    return element;\n  }\n\n  /**\n   * Trigger the actual pattern match and package the matched\n   * response through a callback.\n   */\n  doMatch<T>(\n    string: string,\n    pattern: RegExp | string,\n    callback: MatchCallback<T>,\n    isVoid: boolean = false,\n  ): MatchResponse<T> | null {\n    return match(string, pattern, callback, isVoid);\n  }\n\n  /**\n   * Callback triggered before parsing.\n   */\n  onBeforeParse(content: string, props: Props): string {\n    return content;\n  }\n\n  /**\n   * Callback triggered after parsing.\n   */\n  onAfterParse(content: Node[], props: Props): Node[] {\n    return content;\n  }\n\n  /**\n   * Replace the match with a React element based on the matched token and optional props.\n   */\n  abstract replaceWith(children: ChildrenNode, props: Props): Node;\n\n  /**\n   * Defines the HTML tag name that the resulting React element will be.\n   */\n  abstract asTag(): string;\n\n  /**\n   * Attempt to match against the defined string. Return `null` if no match found,\n   * else return the `match` and any optional props to pass along.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  abstract match(string: string): MatchResponse<any> | null;\n}\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType } from './utils';\nvar propTypes = {\n  tag: tagPropType,\n  listTag: tagPropType,\n  className: PropTypes.string,\n  listClassName: PropTypes.string,\n  cssModule: PropTypes.object,\n  children: PropTypes.node,\n  'aria-label': PropTypes.string\n};\nvar defaultProps = {\n  tag: 'nav',\n  listTag: 'ol',\n  'aria-label': 'breadcrumb'\n};\n\nvar Breadcrumb = function Breadcrumb(props) {\n  var className = props.className,\n      listClassName = props.listClassName,\n      cssModule = props.cssModule,\n      children = props.children,\n      Tag = props.tag,\n      ListTag = props.listTag,\n      label = props['aria-label'],\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"listClassName\", \"cssModule\", \"children\", \"tag\", \"listTag\", \"aria-label\"]);\n\n  var classes = mapToCssModules(classNames(className), cssModule);\n  var listClasses = mapToCssModules(classNames('breadcrumb', listClassName), cssModule);\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    \"aria-label\": label\n  }), /*#__PURE__*/React.createElement(ListTag, {\n    className: listClasses\n  }, children));\n};\n\nBreadcrumb.propTypes = propTypes;\nBreadcrumb.defaultProps = defaultProps;\nexport default Breadcrumb;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType } from './utils';\nvar propTypes = {\n  tag: tagPropType,\n  active: PropTypes.bool,\n  className: PropTypes.string,\n  cssModule: PropTypes.object\n};\nvar defaultProps = {\n  tag: 'li'\n};\n\nvar BreadcrumbItem = function BreadcrumbItem(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      active = props.active,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"cssModule\", \"active\", \"tag\"]);\n\n  var classes = mapToCssModules(classNames(className, active ? 'active' : false, 'breadcrumb-item'), cssModule);\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    \"aria-current\": active ? 'page' : undefined\n  }));\n};\n\nBreadcrumbItem.propTypes = propTypes;\nBreadcrumbItem.defaultProps = defaultProps;\nexport default BreadcrumbItem;"],"names":["matchHtmlRegExp","module","exports","string","escape","str","match","exec","html","index","lastIndex","length","charCodeAt","substring","children","Element","arguments","_ref","attributes","_ref$attributes","className","selfClose","Filter","attribute","name","_proto","TYPE_EMBEDDED","_node","TYPE_INTERACTIVE","tagConfigs","type","TYPE_FLOW","void","content","body","button","TYPE_PHRASING","caption","br","col","parent","colgroup","details","invalid","header","dt","img","main","self","ol","picture","li","rp","rt","rtc","ruby","source","summary","table","tbody","tfoot","thead","track","video","tr","wbr","ul","tagName","forEach","createConfigBuilder","config","freeze","BANNED_TAG_LIST","FILTER_DENY","FILTER_CAST_BOOL","FILTER_NO_CAST","ATTRIBUTES","cite","class","Object","colspan","FILTER_CAST_NUMBER","tag","label","FILTER_ALLOW","lang","loading","loop","media","muted","poster","role","rowspan","scope","sizes","span","start","style","src","srclang","srcset","target","title","width","datetime","key","INVALID_STYLES","ELEMENT_NODE","TEXT_NODE","apply","container","StyleFilter","createDocument","value","allowed","window","undefined","constructor","keyIndex","createHTMLDocument","blocked","props","blockList","filters","applyNodeFilters","matchers","matchedString","concat","elementIndex","parts","this","matcher","allowList","ALLOWED_TAG_LIST","Set","getTagConfig","canRenderChild","_proto3","valid","partProps","filter","nextNode","node","parentConfig","elements","_parts","isVoid","tokenName","replaceTokens","tokenizedString","childConfig","_this","_match","slice","nextMarkup","replace","includes","createContainer","doc","el","createElement","noHtml","disableLineBreaks","attr","toLowerCase","global","allowAttributes","ATTRIBUTES_TO_PROPS","count","Array","extractStyleAttribute","newName","from","styles","common","Number","_this2","HTMLAnchorElement","letter","getAttribute","isTagAllowed","parseNode","parentNode","noHtmlExceptMatchers","protocol","allowElements","push","React","cloneElement","transform","transformOnlyAllowList","has","mergedText","elementProps","transformed","text","_this3","nodes","open","__DEV__","endIndex","close","startIndex","containerTagName","_elements$tokenName","emptyContent","parsedContent","noWrap","mainContent","onAfterParse","onBeforeParse","parserProps","allMatchers","disableMatchers","allFilters","disableFilters","beforeCallbacks","afterCallbacks","markup","nextString","parser","isArray","_props$content","TypeError","_props$disableFilters","_props$disableMatcher","_props$emptyContent","_props$filters","_props$matchers","_props$onAfterParse","_props$onBeforeParse","_props$noWrap","matches","bind","element","propTypes","tagPropType","listTag","PropTypes","listClassName","cssModule","Breadcrumb","Tag","ListTag","_objectWithoutPropertiesLoose","classes","mapToCssModules","classNames","listClasses","_extends","defaultProps","active","BreadcrumbItem"],"sourceRoot":""}